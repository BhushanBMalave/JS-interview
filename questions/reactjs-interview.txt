1) Hooks:

1ï¸âƒ£ useState
What is it?
Used to manage local state in functional components.
When state changes â†’ component re-renders.

Syntax
const [state, setState] = useState(initialValue);

Example
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </>
  );
}

Key Interview Points
State updates are asynchronous
Never mutate state directly
Can hold any data type

2ï¸âƒ£ useEffect
What is it?
Used to handle side effects
API calls
Subscriptions
Timers
DOM updates

Syntax
useEffect(() => {
  // side effect
  return () => {
    // cleanup
  };
}, [dependencies]);

Example â€“ API Call
import { useEffect, useState } from "react";

function Users() {
  const [users, setUsers] = useState([]);

  useEffect(() => {
    fetch("/api/users")
      .then(res => res.json())
      .then(data => setUsers(data));
  }, []);

  return <div>{users.length} users</div>;
}

Dependency Variations
Dependency	Behavior
[]        	Runs once (on mount)
[value]	   Runs when value changes
No array	  Runs on every render

3ï¸âƒ£ useContext
What is it?
Used to avoid prop drilling
Access shared data across components

Example
Create Context
const ThemeContext = React.createContext();

Provide Context
function App() {
  return (
    <ThemeContext.Provider value="dark">
      <Child />
    </ThemeContext.Provider>
  );
}

Consume Context
function Child() {
  const theme = useContext(ThemeContext);
  return <div>{theme}</div>;
}

Interview Notes
Works best with global data
Re-renders all consuming components when value changes.

4ï¸âƒ£ useReducer
What is it?
Alternative to useState
Best for complex state logic
Similar to Redux pattern

Syntax
const [state, dispatch] = useReducer(reducer, initialState);

Example
function reducer(state, action) {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };
    default:
      return state;
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, { count: 0 });

  return (
    <>
      <p>{state.count}</p>
      <button onClick={() => dispatch({ type: "increment" })}>
        Increment
      </button>
    </>
  );
}

Interview Tip
ğŸ‘‰ Use useReducer when:
Multiple state values
Complex updates
State depends on previous state

5ï¸âƒ£ useMemo
What is it?
Memoizes computed values
Prevents expensive recalculations

Syntax
const memoizedValue = useMemo(() => compute(), [deps]);

Example
const expensiveValue = useMemo(() => {
  return items.reduce((sum, item) => sum + item.price, 0);
}, [items]);

Interview Notes
Improves performance
Do not overuse
Only for expensive calculations

6ï¸âƒ£ useCallback
What is it?

Memoizes functions

Prevents unnecessary child re-renders

Syntax
const memoizedFn = useCallback(() => {}, [deps]);

Example
const handleClick = useCallback(() => {
  console.log("Clicked");
}, []);

Difference: useMemo vs useCallback
Hook	       Memoizes
useMemo	    Value
useCallback	Function

7ï¸âƒ£ useRef
What is it?
Holds mutable values
Does not cause re-render
Access DOM elements

Example â€“ DOM Reference
import { useRef } from "react";

function InputFocus() {
  const inputRef = useRef(null);

  return (
    <>
      <input ref={inputRef} />
      <button onClick={() => inputRef.current.focus()}>
        Focus
      </button>
    </>
  );
}

Example â€“ Store Previous Value
const prevCount = useRef(0);

Interview Points
Changes donâ€™t trigger re-render
Useful for timers, DOM, previous state

ğŸ”¥ Common Interview Questions
Q: Can hooks be used inside loops or conditions?
âŒ No â€” only at the top level

Q: Why hooks were introduced?
âœ” To use state & lifecycle features in functional components

Q: Which hook replaces lifecycle methods?
âœ” useEffect

2) Higher Order Components (HOC):
ğŸ”¹ What is a Higher Order Component?
A Higher Order Component is a function that:
Takes a component as input
Returns a new enhanced component

syntax
const EnhancedComponent = higherOrderComponent(OriginalComponent);

â¡ï¸ It does not modify the original component
â¡ï¸ It wraps the component with extra behavior

ğŸ”¹ Why use HOC?
Code reusability
Separation of concerns
Avoid repeating the same logic across components
Cleaner, maintainable code

ğŸ”¹ When to use HOC?
Authentication / Authorization
Logging
Error handling
Injecting props
Conditional rendering

ğŸ”¹ Basic HOC Example
HOC to add logging
function withLogger(WrappedComponent) {
  return function EnhancedComponent(props) {
    console.log("Props:", props);
    return <WrappedComponent {...props} />;
  };
}

Normal Component
function Profile({ name }) {
  return <h2>Hello {name}</h2>;
}

Enhanced Component
const ProfileWithLogger = withLogger(Profile);

Usage
<ProfileWithLogger name="Bhushan" />

ğŸ” What happens?
withLogger receives Profile
Returns a new component
Logs props
Renders original component

ğŸ”¹ Authentication HOC (Very Common Interview Question)
HOC
function withAuth(WrappedComponent) {
  return function AuthComponent(props) {
    const isLoggedIn = true;

    if (!isLoggedIn) {
      return <p>Please login</p>;
    }

    return <WrappedComponent {...props} />;
  };
}

Component
function Dashboard() {
  return <h1>Dashboard</h1>;
}

Wrapped
export default withAuth(Dashboard);

Explanation
If user is authenticated â†’ show component
Else â†’ block access

ğŸ”¹ HOC with API Data
function withData(WrappedComponent) {
  return function DataComponent(props) {
    const [data, setData] = React.useState([]);

    React.useEffect(() => {
      fetch("/api/data")
        .then(res => res.json())
        .then(setData);
    }, []);

    return <WrappedComponent data={data} {...props} />;
  };
}

ğŸ”¹ Passing Props Correctly
âœ” Always forward props:
<WrappedComponent {...props} />


âŒ Wrong:
<WrappedComponent />

ğŸ”¹ Naming Convention (Best Practice)
withAuth(Component)
withLogger(Component)
withLoading(Component)

ğŸ”¹ HOC vs Hooks (Interview Favorite)
HOC	              Hooks
Used before Hooks	Introduced in React 16.8
Wrapper component	Function-based logic
Can cause wrapper hell	Cleaner & simpler
Still used in libraries	Preferred for new code

ğŸ‘‰ Hooks are preferred today, but HOCs are still important to understand.

ğŸ”¹ Common Pitfalls
âŒ Modifying original component
âŒ Forgetting to pass props
âŒ Too many nested HOCs

ğŸ”¹ Real-World Usage
connect() from Redux
withRouter() from React Router (v5)
Error boundaries (older pattern)

ğŸ”¥ One-Line Interview Answer
A Higher Order Component is a function that takes a component and returns a new component with added functionality, enabling code reuse and separation of concerns.

3) Life Cycle Methods of Components:
Class Components: Traditional React components using ES6 classes.
Mounting: Component is being created and inserted into the DOM.
Updating: Component is being re-rendered as a result of changes.
Unmounting: Component is being removed from the DOM.  deatiled notes for interview with examples

Below are detailed, interview-ready notes on React Life Cycle Methods (Class Components) with clear explanations, execution order, and examples. You can confidently answer both theory + practical questions from this ğŸ‘‡

3ï¸âƒ£ Life Cycle Methods of Components (Class Components)
ğŸ”¹ What are Class Components?

Class components are traditional React components written using ES6 classes.
They:
Extend React.Component
Can hold state
Use lifecycle methods
class MyComponent extends React.Component {
  render() {
    return <div>Hello</div>;
  }
}

ğŸ”¹ What are Lifecycle Methods?
Lifecycle methods are predefined methods that are automatically called by React at different stages of a componentâ€™s life:
Mounting
Updating
Unmounting

ğŸ”µ 1. Mounting Phase
ğŸ‘‰ When the component is created and inserted into the DOM

Order of Execution
constructor()
render()
componentDidMount()

1ï¸âƒ£ constructor(props)
Purpose:
Initialize state
Bind event handlers

constructor(props) {
  super(props);
  this.state = { count: 0 };
}

ğŸ“Œ Interview Notes
Always call super(props)
Do not make API calls here

2ï¸âƒ£ render()
Purpose:
Returns JSX
Determines UI

render() {
  return <h2>Count: {this.state.count}</h2>;
}

ğŸ“Œ Interview Notes
Must be a pure function
No side effects
Called on every render

3ï¸âƒ£ componentDidMount()
Purpose:
Runs after component is mounted
Used for:
API calls
Subscriptions
Timers

componentDidMount() {
  console.log("Component Mounted");
}

ğŸ“Œ Interview Notes
Runs only once
Best place for async operations

ğŸŸ¡ 2. Updating Phase
ğŸ‘‰ Happens when:
State changes (setState)
Props change

Updating Lifecycle Methods
1ï¸âƒ£ shouldComponentUpdate(nextProps, nextState)
Purpose:
Decide whether component should re-render
shouldComponentUpdate(nextProps, nextState) {
  return nextState.count !== this.state.count;
}

ğŸ“Œ Interview Notes
Improves performance
Returns true or false

2ï¸âƒ£ render()
Re-renders UI based on new state/props

3ï¸âƒ£ componentDidUpdate(prevProps, prevState)
Purpose:
Run logic after update
componentDidUpdate(prevProps, prevState) {
  if (prevState.count !== this.state.count) {
    console.log("Count Updated");
  }
}

ğŸ“Œ Interview Notes
Use conditions to avoid infinite loops
Common for dependent API calls

Updating Order
shouldComponentUpdate()
render()
componentDidUpdate()

ğŸ”´ 3. Unmounting Phase
ğŸ‘‰ When component is removed from the DOM
componentWillUnmount()

Purpose:
Cleanup operations:
Clear timers
Remove event listeners
Cancel subscriptions

componentWillUnmount() {
  console.log("Component Unmounted");
}


ğŸ“Œ Interview Notes
Prevents memory leaks
Called once before removal

ğŸ§© Complete Example (All Phases)

class LifeCycleDemo extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
    console.log("Constructor");
  }

  componentDidMount() {
    console.log("Mounted");
  }

  shouldComponentUpdate(nextProps, nextState) {
    return true;
  }

  componentDidUpdate() {
    console.log("Updated");
  }

  componentWillUnmount() {
    console.log("Unmounted");
  }

  render() {
    console.log("Render");
    return (
      <>
        <p>{this.state.count}</p>
        <button onClick={() => this.setState({ count: this.state.count + 1 })}>
          Increment
        </button>
      </>
    );
  }
}

ğŸ” Lifecycle Methods vs Hooks (Interview Favorite)
Class Lifecycle	         Hook Equivalent
constructor	             useState()
componentDidMount	       useEffect(() => {}, [])
componentDidUpdate	      useEffect(() => {}, [deps])
componentWillUnmount	    useEffect(() => return cleanup)

âŒ Deprecated Lifecycle Methods
(Asked occasionally)
componentWillMount
componentWillReceiveProps
componentWillUpdate

â¡ï¸ Replaced by hooks and safer alternatives
ğŸ”¥ Common Interview Questions & Answers
Q: Where should API calls be made?
âœ” componentDidMount
Q: How do you prevent unnecessary re-renders?
âœ” shouldComponentUpdate
Q: Where do you clean up subscriptions?
âœ” componentWillUnmount

âœ… One-Line Interview Answer
React lifecycle methods are special methods in class components that allow developers to run code during mounting, updating, and unmounting phases of a component.

4) State management (all about data):
ğŸ”¹ What is State Management?
State management is how an application stores, updates, and shares data between components so the UI stays in sync with the data.

ğŸ”µ 1. State vs Props

ğŸ”¹ State
Internal data managed by the component itself
Can change over time
Triggers re-render

Example â€“ State
function Counter() {
  const [count, setCount] = React.useState(0);

  return (
    <>
      <p>{count}</p>
      <button onClick={() => setCount(count + 1)}>+</button>
    </>
  );
}

Interview Points
âœ” Local to component
âœ” Mutable via setState / setter
âœ” Causes re-render

ğŸ”¹ Props
External data passed from parent to child
Read-only
Cannot be modified by child

Example â€“ Props
function Child({ name }) {
  return <h3>Hello {name}</h3>;
}

function Parent() {
  return <Child name="Bhushan" />;
}

Interview Points
âœ” Passed from parent to child
âœ” Immutable
âœ” Enables component reuse

ğŸ”¥ State vs Props (Comparison)
Feature	State	Props
Managed by	Component itself	Parent
Mutability	Mutable	Immutable
Purpose	Store dynamic data	Pass data
Re-render	Yes	Yes

ğŸŸ¡ 2. Props Drilling
ğŸ”¹ What is Props Drilling?
Props drilling occurs when data is passed through multiple intermediate components that donâ€™t need the data, just to reach a deeply nested child.

Example â€“ Props Drilling Problem
function App() {
  const user = "Bhushan";
  return <Parent user={user} />;
}

function Parent({ user }) {
  return <Child user={user} />;
}

function Child({ user }) {
  return <GrandChild user={user} />;
}

function GrandChild({ user }) {
  return <h1>{user}</h1>;
}

Problems
âŒ Unnecessary props
âŒ Hard to maintain
âŒ Tightly coupled components

ğŸŸ¢ 3. Context API (Solution to Props Drilling)
ğŸ”¹ What is Context?
Context allows you to share data globally without passing props manually at every level.

ğŸ”¹ When to Use Context?
Theme (dark/light)
User authentication
Language settings
Global app config

ğŸ”¹ Context Example (Step by Step)
1ï¸âƒ£ Create Context
const UserContext = React.createContext();

2ï¸âƒ£ Provide Context
function App() {
  const user = "Bhushan";

  return (
    <UserContext.Provider value={user}>
      <Parent />
    </UserContext.Provider>
  );
}

3ï¸âƒ£ Consume Context
function GrandChild() {
  const user = React.useContext(UserContext);
  return <h1>{user}</h1>;
}

ğŸ”¹ Without Props Drilling
No need to pass props through Parent â†’ Child
Direct access to data

ğŸ”¥ Props Drilling vs Context
Feature	        Props       Drilling	Context
Data passing	   Manual	     Automatic
Maintainability	 Poor       	Better
Best for	       Small apps	 Medium/large apps
Performance	     Better	     Can cause re-renders

ğŸ§  Real-World Example: Theme Context
const ThemeContext = React.createContext();

function App() {
  return (
    <ThemeContext.Provider value="dark">
      <Navbar />
    </ThemeContext.Provider>
  );
}

function Navbar() {
  return <ThemeButton />;
}

function ThemeButton() {
  const theme = React.useContext(ThemeContext);
  return <button>{theme}</button>;
}

âš ï¸ Context Performance Tip (Interview Bonus)
Context updates re-render all consumers
Avoid using context for frequently changing data
Combine with useMemo if needed

ğŸ” Context vs Redux (Quick Interview Answer)
Context â†’ Data sharing
Redux â†’ State management library
Context is not a Redux replacement

ğŸ”¥ Common Interview Questions
Q: Can a child modify props?
âŒ No
Q: Why props are immutable?
âœ” To ensure predictable data flow
Q: Does Context replace Redux?
âŒ No, it only solves prop drilling

âœ… One-Line Interview Answer
State management in React deals with how data is stored, passed, and shared across components using state, props, props drilling, and Context API.

5) Redux
ğŸ”¹ What is Redux?
Redux is a predictable state container for JavaScript applications that provides a single source of truth for the entire app.
All application state is stored in one global store.

ğŸ”¹ Why Redux?
Redux solves problems like:
Props drilling
Inconsistent state
Difficult debugging
Managing shared state across many components

ğŸ”¹ When Should You Use Redux?
âœ… Large applications
âœ… Multiple components need the same data
âœ… Complex state transitions
âŒ Small apps (Context is enough)

ğŸ”µ Core Redux Concepts
1ï¸âƒ£ Store
Holds the entire app state
Only one store per app

const store = createStore(reducer);

2ï¸âƒ£ Action
Plain JavaScript object
Describes what happened

{
  type: "INCREMENT",
  payload: 1
}

ğŸ“Œ Actions are read-only

3ï¸âƒ£ Reducer
A pure function
Takes current state + action
Returns new state

function counterReducer(state = { count: 0 }, action) {
  switch (action.type) {
    case "INCREMENT":
      return { count: state.count + action.payload };
    default:
      return state;
  }
}

4ï¸âƒ£ Dispatch
Sends an action to the store

store.dispatch({ type: "INCREMENT", payload: 1 });

5ï¸âƒ£ Selector
Reads data from the store

const count = useSelector(state => state.counter.count);

ğŸ” How Redux Works (Data Flow)
Component â†’ Dispatch Action â†’ Reducer â†’ Store â†’ UI Update

UI triggers an action
Action is dispatched
Reducer calculates new state
Store updates
UI re-renders

â¡ï¸ One-way data flow
ğŸŸ¡ Redux Example (Without Toolkit)

import { createStore } from "redux";

const reducer = (state = { count: 0 }, action) => {
  switch (action.type) {
    case "INC":
      return { count: state.count + 1 };
    default:
      return state;
  }
};

const store = createStore(reducer);

âŒ Too much boilerplate
âŒ Manual immutability
âŒ Extra setup

ğŸŸ¢ Redux Toolkit (RTK)
ğŸ”¹ What is Redux Toolkit?
Redux Toolkit is the official, recommended way to write Redux logic.

âœ” Less boilerplate
âœ” Built-in best practices
âœ” Uses Immer internally
âœ” Easy async handling

ğŸ”¹ RTK Core APIs
API	Purpose
configureStore	Create store
createSlice	Create reducer + actions
createAsyncThunk	Handle async logic

ğŸ§© RTK Example (Step-by-Step)
1ï¸âƒ£ Create Slice
import { createSlice } from "@reduxjs/toolkit";

const counterSlice = createSlice({
  name: "counter",
  initialState: { count: 0 },
  reducers: {
    increment(state) {
      state.count += 1; // mutating (safe via Immer)
    },
    decrement(state) {
      state.count -= 1;
    }
  }
});

export const { increment, decrement } = counterSlice.actions;
export default counterSlice.reducer;

2ï¸âƒ£ Configure Store
import { configureStore } from "@reduxjs/toolkit";
import counterReducer from "./counterSlice";

export const store = configureStore({
  reducer: {
    counter: counterReducer
  }
});

3ï¸âƒ£ Provide Store
import { Provider } from "react-redux";
import { store } from "./store";

<Provider store={store}>
  <App />
</Provider>

4ï¸âƒ£ Use in Component
import { useDispatch, useSelector } from "react-redux";
import { increment } from "./counterSlice";

function Counter() {
  const count = useSelector(state => state.counter.count);
  const dispatch = useDispatch();

  return (
    <>
      <p>{count}</p>
      <button onClick={() => dispatch(increment())}>+</button>
    </>
  );
}

âš¡ Async Logic with RTK (createAsyncThunk)
export const fetchUsers = createAsyncThunk(
  "users/fetch",
  async () => {
    const res = await fetch("/api/users");
    return res.json();
  }
);


Used inside slice:

extraReducers: builder => {
  builder
    .addCase(fetchUsers.pending, state => {
      state.loading = true;
    })
    .addCase(fetchUsers.fulfilled, (state, action) => {
      state.loading = false;
      state.users = action.payload;
    });
}

ğŸ”¥ Redux vs Context (Interview Must-Know)
Redux	                Context
State management	     Data sharing
Predictable updates	  Simple
Middleware support	   No middleware
Best for large apps	  Small/medium apps

â“ Common Interview Questions
Q: Why reducers must be pure?
âœ” To ensure predictable state updates

Q: Why single source of truth?
âœ” Easier debugging & consistency

Q: Is Redux synchronous?
âœ” Core Redux is synchronous; async handled via middleware/RTK

âœ… One-Line Interview Answer
Redux is a centralized state management library that uses actions and reducers to manage application state in a predictable, one-way data flow, and Redux Toolkit simplifies its setup and usage.

6) Custom Hooks:
ğŸ”¹ What are Custom Hooks?
A Custom Hook is a JavaScript function:
Whose name starts with use
That uses other hooks internally
Returns stateful logic (state, functions, values)

function useSomething() {
  // hook logic
}

ğŸ‘‰ Custom Hooks do not return JSX, they return logic.

ğŸ”¹ Why Custom Hooks?
Custom Hooks solve:
Repeated logic across components
Messy components with too much logic
Poor readability and maintainability

âœ” Better code reuse
âœ” Clean components
âœ” Separation of concerns

ğŸ”¹ When to Use Custom Hooks?
Use them when:
Same useEffect + useState logic is repeated
Logic is shared across multiple components
Component becomes too large
Business logic needs isolation

ğŸ”¹ Rules of Custom Hooks (Interview Must-Know)
Name must start with use
Call hooks only at top level
Can call other hooks
Cannot be called conditionally

ğŸ”µ Simple Custom Hook Example
âŒ Without Custom Hook
function ComponentA() {
  const [count, setCount] = React.useState(0);
  return <button onClick={() => setCount(count + 1)}>{count}</button>;
}

function ComponentB() {
  const [count, setCount] = React.useState(0);
  return <button onClick={() => setCount(count + 1)}>{count}</button>;
}

âœ… With Custom Hook
function useCounter(initialValue = 0) {
  const [count, setCount] = React.useState(initialValue);

  const increment = () => setCount(c => c + 1);

  return { count, increment };
}

Usage
function Counter() {
  const { count, increment } = useCounter(0);
  return <button onClick={increment}>{count}</button>;
}

ğŸŸ¡ Custom Hook with useEffect (API Logic)
function useFetch(url) {
  const [data, setData] = React.useState(null);
  const [loading, setLoading] = React.useState(true);

  React.useEffect(() => {
    fetch(url)
      .then(res => res.json())
      .then(data => {
        setData(data);
        setLoading(false);
      });
  }, [url]);

  return { data, loading };
}

Usage
function Users() {
  const { data, loading } = useFetch("/api/users");

  if (loading) return <p>Loading...</p>;
  return <div>{data.length} users</div>;
}

ğŸŸ¢ Custom Hook for Window Size
function useWindowSize() {
  const [width, setWidth] = React.useState(window.innerWidth);

  React.useEffect(() => {
    const handleResize = () => setWidth(window.innerWidth);
    window.addEventListener("resize", handleResize);

    return () => window.removeEventListener("resize", handleResize);
  }, []);

  return width;
}

ğŸ”¥ Custom Hook vs HOC vs Render Props
Pattern	         Purpose	         Complexity
Custom Hook	Reuse logic	Simple
HOC	Enhance components	Medium
Render Props	Share render logic	Complex

ğŸ‘‰ Custom Hooks are preferred today

ğŸ§  Real-World Custom Hooks
useAuth
useDebounce
usePrevious
useLocalStorage

Example: useLocalStorage
function useLocalStorage(key, initialValue) {
  const [value, setValue] = React.useState(() => {
    return JSON.parse(localStorage.getItem(key)) ?? initialValue;
  });

  React.useEffect(() => {
    localStorage.setItem(key, JSON.stringify(value));
  }, [key, value]);

  return [value, setValue];
}

âš ï¸ Common Mistakes (Interview Traps)
âŒ Returning JSX
âŒ Calling hook conditionally
âŒ Forgetting dependency array

ğŸ”¥ Common Interview Questions
Q: Can custom hooks use other hooks?
âœ” Yes

Q: Do custom hooks share state?
âŒ No, logic is shared, not state

Q: Why must hook names start with use?
âœ” React relies on naming convention for rules enforcement

âœ… One-Line Interview Answer
Custom Hooks are reusable functions that encapsulate React hook logic to improve code reusability, readability, and separation of concerns.

7) Lazy Loading:
ğŸ”¹ What is Lazy Loading?
Lazy loading is a performance optimization technique where components or resources are loaded only when needed, instead of loading everything at once.

âœ” Faster initial load
âœ” Smaller bundle size
âœ” Better user experience

ğŸ”µ 1. Code Splitting
ğŸ”¹ What is Code Splitting?
Code splitting means breaking a large JavaScript bundle into smaller chunks so that only required code is loaded.

Without Code Splitting
Entire app JS loads at once
Slow initial page load

With Code Splitting
Only essential code loads first
Remaining code loads on demand

ğŸ”¹ React Support for Code Splitting
React supports code splitting using:
React.lazy()
Dynamic import()

Example â€“ Without Lazy Loading
import Dashboard from "./Dashboard";

function App() {
  return <Dashboard />;
}
âŒ Dashboard loaded even if user never visits it

Example â€“ With Code Splitting
const Dashboard = React.lazy(() => import("./Dashboard"));
âœ” Dashboard loaded only when rendered

ğŸŸ¡ 2. Chunking
ğŸ”¹ What is Chunking?
Chunking is the result of code splitting, where:
App code is divided into chunks
Each chunk is loaded independently

ğŸ“Œ Bundlers like Webpack / Vite handle chunk creation automatically.

Example â€“ Route-Based Chunking
import { Routes, Route } from "react-router-dom";

const Home = React.lazy(() => import("./Home"));
const About = React.lazy(() => import("./About"));

function App() {
  return (
    <React.Suspense fallback={<p>Loading...</p>}>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
      </Routes>
    </React.Suspense>
  );
}

âœ” Each route loads its own chunk
âœ” Better performance for large apps

ğŸŸ¢ 3. React.Suspense
ğŸ”¹ What is Suspense?
Suspense allows React to:
Pause rendering
Show a fallback UI
Resume once lazy component is loaded

Syntax
<Suspense fallback={<Loading />}>
  <LazyComponent />
</Suspense>

Example â€“ Component Level
const Profile = React.lazy(() => import("./Profile"));

function App() {
  return (
    <React.Suspense fallback={<div>Loading Profile...</div>}>
      <Profile />
    </React.Suspense>
  );
}

Example â€“ Nested Suspense
<Suspense fallback={<Spinner />}>
  <MainLayout>
    <Suspense fallback={<p>Loading section...</p>}>
      <HeavyComponent />
    </Suspense>
  </MainLayout>
</Suspense>


âœ” Different loading states
âœ” Better UX

ğŸ”¥ Lazy Loading Images (Bonus)
<img src="image.jpg" loading="lazy" alt="example" />

âš ï¸ Important Interview Notes
âŒ Common Mistakes
Using React.lazy without Suspense
Lazy loading very small components
Forgetting fallback UI

ğŸ” Lazy Loading vs Normal Import
Feature	Normal Import	Lazy Loading
Load time	App start	On demand
Bundle size	Large	Smaller
Performance	Slower	Faster

ğŸ§  Real-World Use Cases
Large dashboards
Admin panels
Route-based navigation
Heavy third-party libraries

ğŸ”¥ Common Interview Questions
Q: Does React.lazy work with named exports?
âŒ No (default export only)

Q: Can Suspense be used for data fetching?
âœ” Experimental (stable for code splitting)

Q: Is lazy loading SEO-friendly?
âœ” Yes (with SSR)

âœ… One-Line Interview Answer
Lazy loading is a performance optimization technique where React loads components only when required using code splitting, chunking, and Suspense.

8) Virtual DOM:
ğŸ”¹ What is the Virtual DOM?
The Virtual DOM (VDOM) is a lightweight JavaScript representation of the real DOM.

It is an in-memory tree
Describes what the UI should look like
Faster to update than the real DOM

const vdom = {
  type: "h1",
  props: { children: "Hello" }
};


ğŸ‘‰ React never directly updates the real DOM first.

ğŸ”µ Rendering in React (High Level)
What is a Render?
A render is the process of:
Executing component functions / render methods
Creating a new Virtual DOM tree
Comparing it with the previous one
Updating only the necessary parts of the real DOM

ğŸ” Render Flow (Interview Explanation)
State / Props change
        â†“
Component re-renders
        â†“
New Virtual DOM created
        â†“
Diffing (Reconciliation)
        â†“
Minimal DOM updates (Commit phase)

ğŸŸ¡ Reconciliation Algorithm
ğŸ”¹ What is Reconciliation?
Reconciliation is the process where React:
Compares old VDOM with new VDOM
Figures out what changed
Updates only those changes in the real DOM

ğŸ‘‰ This makes React fast and efficient.

ğŸ”¹ Key Assumptions of Diff Algorithm
React uses heuristics (rules) to optimize diffing:

1ï¸âƒ£ Elements with different types â†’ replace entire subtree
2ï¸âƒ£ Elements with same type â†’ update only changed props
3ï¸âƒ£ Lists use keys to identify elements

Example â€“ Same Element Type
<h1 className="red">Hello</h1>
<h1 className="blue">Hello</h1>

âœ” Only className is updated
âŒ DOM node is not recreated

Example â€“ Different Element Type
<h1>Hello</h1>
<p>Hello</p>

âŒ h1 destroyed
âœ” p created

Example â€“ Lists & Keys
{items.map(item => (
  <li key={item.id}>{item.name}</li>
))}

âœ” Keys help React identify:
Insertions
Deletions
Reorering

âŒ Using index as key â†’ bad for dynamic lists

ğŸŸ¢ Diff Algorithm (Simplified)
ğŸ”¹ What is Diffing?
Diffing is the comparison process between:
Previous Virtual DOM
Current Virtual DOM
Goal: Find minimal changes

Example
<ul>
  <li>A</li>
  <li>B</li>
</ul>

Update:
<ul>
  <li>A</li>
  <li>C</li>
</ul>

âœ” React updates only text B â†’ C
âŒ Does not recreate <ul>

ğŸ”´ React Fiber
ğŸ”¹ What is React Fiber?
React Fiber is a complete reimplementation of Reactâ€™s core reconciliation algorithm (introduced in React 16).

Why Fiber?
Old React:
Synchronous rendering
UI could block on heavy updates

Fiber:
Breaks rendering into units of work
Can pause, resume, or cancel work
Prioritizes updates

ğŸ”¹ Benefits of React Fiber
âœ” Smooth animations
âœ” Better responsiveness
âœ” Concurrent rendering
âœ” Error boundaries support

ğŸ”¹ Fiber Concepts (Interview Level)
Work Units: Small pieces of render work
Priority: Urgent updates first
Time Slicing: Pause work to keep UI responsive

ğŸ”µ How Does render() Work?
ğŸ”¹ Render in Class Component
render() {
  return <h1>{this.state.count}</h1>;
}

Called when:
State changes
Props change
Should be pure
Does not modify DOM directly

ğŸ”¹ Render in Functional Component
function Counter() {
  return <h1>Counter</h1>;
}

Same process:
âœ” Function executes
âœ” VDOM created â†’ compared â†’ committed

âš ï¸ Important Interview Clarifications
â“ Does render mean DOM update?
âŒ No
âœ” Render = creating Virtual DOM
âœ” Commit phase = DOM update

ğŸ§  Render vs Commit Phase
Phase	Description
Render	Calculate UI (VDOM)
Commit	Apply changes to real DOM
ğŸ”¥ Common Interview Questions

Q: Is Virtual DOM faster than Real DOM?
âœ” Updating VDOM is faster; DOM updates are minimized

Q: Why are keys important?
âœ” Helps React identify elements during diffing

Q: Does state change always cause re-render?
âœ” Yes, unless optimized (memo, shouldComponentUpdate)

âœ… One-Line Interview Answer
The Virtual DOM is an in-memory representation of the UI that React uses to efficiently update the real DOM through reconciliation, diffing, and the Fiber architecture.

9) SSR vs CSR (important):
ğŸ”¹ What is Rendering?
Rendering is the process of converting components into HTML that the browser can display.

ğŸ”µ Client-Side Rendering (CSR)
ğŸ”¹ What is CSR?
In Client-Side Rendering, the browser:
Downloads a minimal HTML file
Downloads JavaScript
JavaScript renders the UI in the browser

ğŸ‘‰ React SPA (Create React App) is CSR by default.

CSR Flow
Request â†’ index.html
        â†’ JS bundle
        â†’ React renders UI
        â†’ Content visible

CSR Example
<!-- index.html -->
<div id="root"></div>

ReactDOM.createRoot(document.getElementById("root")).render(<App />);

Pros of CSR
âœ” Fast navigation after load
âœ” Rich interactivity
âœ” Simple architecture

Cons of CSR
âŒ Poor SEO (empty HTML initially)
âŒ Slower first content paint
âŒ JS-heavy initial load

ğŸ”´ Server-Side Rendering (SSR)
ğŸ”¹ What is SSR?
In Server-Side Rendering, the server:
Generates HTML for each request
Sends fully rendered HTML to the browser

ğŸ‘‰ Common in Next.js

SSR Flow
Request â†’ Server renders HTML
        â†’ HTML sent to browser
        â†’ JS hydrates React

SSR Example (Next.js)
export async function getServerSideProps() {
  const data = await fetch("https://api.example.com/posts").then(res => res.json());
  return { props: { data } };
}

export default function Page({ data }) {
  return <h1>{data.title}</h1>;
}

Pros of SSR
âœ” Better SEO
âœ” Faster initial page load
âœ” Content visible immediately

Cons of SSR
âŒ Higher server load
âŒ Slower navigation after initial load
âŒ More complex setup

ğŸŸ¡ SEO & Performance Comparison
SEO
CSR â†’ Search engines see empty HTML
SSR â†’ Search engines see full content
âœ” SSR is SEO-friendly

Performance
Metric	                   CSR	                             SSR
Initial load	             Slower	                           Faster
TTI (Time to Interactive)	 Faster	                           Slightly slower
Subsequent navigation	     Faster                          	 Fast

ğŸ” CSR vs SSR (Comparison Table)
Feature	                      CSR	                          SSR
Rendering location	          Browser	                      Server
Initial HTML	                Empty	                        Fully rendered
SEO	                          Poor	                        Excellent
First load	                  Slower	                      Faster
Complexity	                  Simple	                      Complex
Server cost	                  Low	                          Higher

ğŸ§  Hydration (Important Interview Term)
ğŸ”¹ What is Hydration?
Hydration is the process where:
React attaches event listeners
Converts server-rendered HTML into a fully interactive app

HTML (from server) + JS â†’ Interactive React App

ğŸŸ¢ When to Use What?
Use CSR when:
Internal dashboards
Admin panels
Apps with low SEO needs
Use SSR when:

Marketing pages
Blogs
E-commerce
SEO-critical apps

ğŸ”¥ CSR vs SSR vs SSG (Bonus)
Type	Description
CSR	Render in browser
SSR	Render on every request
SSG	Render at build time

â“ Common Interview Questions
Q: Is SSR always faster?
âŒ No, only for initial load

Q: Does SSR eliminate JS?
âŒ No, JS is still needed for hydration

Q: Can SSR work without hydration?
âŒ No interactivity without JS

âœ… One-Line Interview Answer
CSR renders content in the browser using JavaScript, while SSR renders HTML on the server, improving SEO and initial page load performance.

10) Routing (Role-based access control-RBAC):
ğŸ”¹ What is Routing in React?
Routing allows a React application to:
Navigate between pages without full page reload
Map URLs to components

ğŸ‘‰ Handled using react-router-dom

ğŸ”¹ What is react-router?
react-router is a standard library for routing in React apps.

Core Components (v6)
BrowserRouter
Routes
Route
Link
useParams
useSearchParams
Navigate

ğŸ”µ How Do You Handle Routes?
Basic Routing Example
import { BrowserRouter, Routes, Route } from "react-router-dom";

function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/login" element={<Login />} />
        <Route path="/dashboard" element={<Dashboard />} />
      </Routes>
    </BrowserRouter>
  );
}

âœ” SPA navigation
âœ” URL-based rendering

ğŸŸ¡ Protected Routes (Authentication)
ğŸ”¹ What is a Protected Route?
A protected route allows access only if the user is authenticated.

Example â€“ Auth Guard
import { Navigate } from "react-router-dom";

function ProtectedRoute({ isAuthenticated, children }) {
  return isAuthenticated ? children : <Navigate to="/login" replace />;
}

Usage
<Route
  path="/dashboard"
  element={
    <ProtectedRoute isAuthenticated={true}>
      <Dashboard />
    </ProtectedRoute>
  }
/>

ğŸ”´ Role-Based Access Control (RBAC)
ğŸ”¹ What is RBAC?
RBAC restricts access to routes based on user roles like:
Admin
User
Manager

RBAC Protected Route Example
function RoleProtectedRoute({ allowedRoles, userRole, children }) {
  if (!allowedRoles.includes(userRole)) {
    return <Navigate to="/unauthorized" replace />;
  }
  return children;
}

Usage
<Route
  path="/admin"
  element={
    <RoleProtectedRoute
      allowedRoles={["admin"]}
      userRole="admin"
    >
      <AdminPanel />
    </RoleProtectedRoute>
  }
/>

ğŸŸ¢ Dynamic Routing
ğŸ”¹ What is Dynamic Routing?
Dynamic routes allow parameters in URLs.

Example
<Route path="/users/:id" element={<UserDetails />} />

Access Param
import { useParams } from "react-router-dom";

function UserDetails() {
  const { id } = useParams();
  return <h1>User ID: {id}</h1>;
}

ğŸŸ£ Query Parameters
ğŸ”¹ What are Query Params?
Extra data passed via URL:
/products?category=books&price=low

Read Query Params
import { useSearchParams } from "react-router-dom";

function Products() {
  const [searchParams] = useSearchParams();
  const category = searchParams.get("category");

  return <h1>Category: {category}</h1>;
}

Set Query Params
searchParams.set("category", "electronics");
setSearchParams(searchParams);

ğŸ” Navigation
Programmatic Navigation
import { useNavigate } from "react-router-dom";

const navigate = useNavigate();
navigate("/dashboard");

ğŸ§  Real-World Routing Structure (RBAC)
<Routes>
  <Route path="/login" element={<Login />} />
  
  <Route
    path="/dashboard"
    element={
      <ProtectedRoute isAuthenticated={true}>
        <Dashboard />
      </ProtectedRoute>
    }
  />

  <Route
    path="/admin"
    element={
      <RoleProtectedRoute
        allowedRoles={["admin"]}
        userRole="admin"
      >
        <Admin />
      </RoleProtectedRoute>
    }
  />
</Routes>

âš ï¸ Common Interview Pitfalls
âŒ Hard-coding roles everywhere
âŒ Not handling unauthorized routes
âŒ Forgetting replace in <Navigate />

ğŸ”¥ Interview Q&A
Q: How do you implement RBAC in React?
âœ” Using protected routes and role checks

Q: Difference between query params & route params?
âœ” Query â†’ optional, Route â†’ required

Q: How do you protect routes?
âœ” Auth & role-based guards

âœ… One-Line Interview Answer
Routing in React is handled using react-router, where protected and role-based routes ensure secure navigation, dynamic routing handles URL parameters, and query params pass optional data.

11) Testing:
ğŸ”¹ Why Testing?
Testing ensures that:
Components work as expected
Bugs are caught early
Refactoring is safe
Code is maintainable

ğŸ‘‰ In interviews, testing = quality mindset

ğŸ”µ React Testing Library (RTL)
ğŸ”¹ What is React Testing Library?

RTL is a testing utility that:
Tests components the way users use them
Focuses on behavior, not implementation
Works with Jest

ğŸ“Œ Guiding principle:
â€œThe more your tests resemble the way your software is used, the more confidence they can give you.â€

ğŸ”¹ What RTL Tests
âœ” Text on screen
âœ” Button clicks
âœ” Form input
âœ” Conditional rendering

âŒ Internal state
âŒ Private methods

ğŸŸ¡ Unit Testing
ğŸ”¹ What is Unit Testing?
Unit testing means testing individual units (functions/components) in isolation.

Example â€“ Simple Component
function Counter() {
  const [count, setCount] = React.useState(0);

  return (
    <>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </>
  );
}

Unit Test Using RTL
import { render, screen, fireEvent } from "@testing-library/react";
import Counter from "./Counter";

test("increments counter on button click", () => {
  render(<Counter />);

  fireEvent.click(screen.getByText("Increment"));

  expect(screen.getByText("Count: 1")).toBeInTheDocument();
});

ğŸ“Œ Interview explanation:
Render component
Simulate user action
Assert expected UI change

ğŸŸ¢ Common RTL Queries (Interview Must-Know)
Query	Use
getByText	Element must exist
queryByText	Element may not exist
findByText	Async element
getByRole	Accessibility-first
Example
screen.getByRole("button", { name: /submit/i });

ğŸ”´ Testing Props & Conditional Rendering
Component
function Greeting({ isLoggedIn }) {
  return isLoggedIn ? <h1>Welcome</h1> : <h1>Please Login</h1>;
}

Test
test("shows welcome when logged in", () => {
  render(<Greeting isLoggedIn={true} />);
  expect(screen.getByText("Welcome")).toBeInTheDocument();
});

ğŸŸ£ Testing Async Code (API Calls)
test("loads users", async () => {
  render(<Users />);
  expect(await screen.findByText("John")).toBeInTheDocument();
});

âš ï¸ What NOT to Test (Interview Tip)
âŒ Implementation details
âŒ Internal state
âŒ Third-party libraries

âœ” Test what user sees and does
ğŸ§  Interview Hack: How to Answer â€œDo You Write Tests?â€

ğŸ‘‰ Best Answer Structure:
I write testable code
I use React Testing Library + Jest
I focus on unit tests
I test user behavior

Hacky Interview Answer (Strong)
I focus on writing testable components with clear responsibilities. I use React Testing Library to write unit tests that simulate real user interactions instead of testing internal implementation details.

ğŸŸ¡ Writing Testable Code (Very Important)
âœ” Good Practices
Small components
Pure functions
Avoid tight coupling
Use data-testid only when needed

<button data-testid="submit-btn">Submit</button>

ğŸ”¥ Common Interview Questions
Q: RTL vs Enzyme?
âœ” RTL tests behavior; Enzyme tests internals

Q: Unit vs Integration tests?
âœ” Unit â†’ single component, Integration â†’ components together

Q: Do you test Redux?
âœ” Test connected components via UI behavior

âœ… One-Line Interview Answer
React Testing Library is used for unit testing React components by simulating real user interactions and asserting UI behavior, helping ensure reliable and maintainable code.

ğŸ§ª JEST â€“ Deep Dive (React Interview Focus)
ğŸ”¹ What is Jest?
Jest is a JavaScript testing framework used for:
Unit testing
Snapshot testing
Mocking functions, APIs, and modules

ğŸ‘‰ Developed by Facebook, works out-of-the-box with React

ğŸ”¹ Why Jest?
âœ” Zero-config (CRA, Vite, Next.js)
âœ” Fast & parallel test execution
âœ” Built-in mocking & assertions
âœ” Snapshot testing support

ğŸ”µ Jest Test Structure
describe("Test Suite", () => {
  beforeEach(() => {});
  afterEach(() => {});

  test("should do something", () => {
    expect(true).toBe(true);
  });
});

ğŸŸ¡ describe, test, it
describe("Math Utils", () => {
  it("adds numbers", () => {
    expect(2 + 3).toBe(5);
  });
});

ğŸ“Œ test and it are the same

ğŸ”µ Matchers (VERY IMPORTANT)
Basic Matchers
expect(5).toBe(5);          // exact match
expect(5).toEqual(5);      // deep equality
expect(true).toBeTruthy();
expect(false).toBeFalsy();

Object & Array Matchers
expect({ a: 1 }).toEqual({ a: 1 });
expect([1,2]).toContain(2);

DOM Matchers (RTL + Jest)
expect(element).toBeInTheDocument();
expect(button).toBeDisabled();

ğŸ”´ Mock Functions (jest.fn())
What?
Creates a mock function to track:
Calls
Arguments
Return values

Example
const mockFn = jest.fn();

mockFn("hello");

expect(mockFn).toHaveBeenCalled();
expect(mockFn).toHaveBeenCalledWith("hello");

Mock Return Value
const add = jest.fn().mockReturnValue(10);

expect(add(2,3)).toBe(10);

ğŸŸ£ Mocking API Calls
Without Real API
global.fetch = jest.fn(() =>
  Promise.resolve({
    json: () => Promise.resolve({ name: "John" })
  })
);

ğŸ”µ Mocking Modules (jest.mock)
jest.mock("./api", () => ({
  fetchUser: jest.fn(() => Promise.resolve("Mock User"))
}));

ğŸ“Œ Used heavily in Redux & async testing

ğŸŸ¢ Mocking Timers (jest.useFakeTimers())
jest.useFakeTimers();

test("timeout test", () => {
  const fn = jest.fn();

  setTimeout(fn, 1000);
  jest.runAllTimers();

  expect(fn).toHaveBeenCalled();
});

ğŸ”´ Snapshot Testing
What?
Takes a UI snapshot and compares future changes.

import renderer from "react-test-renderer";

test("snapshot test", () => {
  const tree = renderer.create(<Button />).toJSON();
  expect(tree).toMatchSnapshot();
});

âš ï¸ Interview tip:
Snapshots should be used sparingly.

ğŸŸ¡ Async Testing
test("async test", async () => {
  const data = await fetchData();
  expect(data).toBe("success");
});


OR

test("async test", () => {
  return fetchData().then(data => {
    expect(data).toBe("success");
  });
});

ğŸ”µ Lifecycle Hooks
Hook	When
beforeAll	Once before tests
beforeEach	Before each test
afterEach	Cleanup
afterAll	Once after all tests
Example
beforeEach(() => {
  jest.clearAllMocks();
});

ğŸ”´ Spying (jest.spyOn())
const obj = {
  greet: () => "hello"
};

jest.spyOn(obj, "greet");

obj.greet();

expect(obj.greet).toHaveBeenCalled();

ğŸŸ¢ Code Coverage
npm test -- --coverage

Shows:
Statements
Branches
Functions
Lines

ğŸ“Œ Interview line:
I ensure critical logic has good coverage but donâ€™t chase 100%.

âš ï¸ Common Jest Mistakes
âŒ Over-mocking
âŒ Snapshot abuse
âŒ Testing implementation details

âœ” Test behavior
âœ” Mock only external dependencies

ğŸ§  Interview Hack â€“ Best Answer
Q: How do you test React apps?
I use Jest as the test runner and assertion library along with React Testing Library. I focus on unit testing components and business logic, mocking APIs and external dependencies, and validating behavior through user interactions.

ğŸ”¥ Jest vs Mocha (Interview)
Jest	Mocha
All-in-one	Needs plugins
Built-in mocking	External libs
Faster setup	Manual setup
âœ… One-Line Summary

Jest is a powerful JavaScript testing framework that provides assertions, mocks, spies, snapshots, and async testing support, making it ideal for testing React applications.

12) Async Tasks:
Async tasks are operations that donâ€™t block the UI thread, such as:
API calls
Timers
User events
Background tasks

ğŸ”µ API Calls (Fetching Data)
Common Ways
fetch
axios

Basic Example
import { useEffect, useState } from "react";

function Users() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetch("/api/users")
      .then(res => res.json())
      .then(data => {
        setUsers(data);
        setLoading(false);
      })
      .catch(err => {
        console.error(err);
        setLoading(false);
      });
  }, []);

  if (loading) return <p>Loading...</p>;

  return users.map(user => <p key={user.id}>{user.name}</p>);
}


ğŸ“Œ Interview points:
API calls are side effects
Should be placed inside useEffect
Handle loading & error states

ğŸ”µ useEffect In-Depth (VERY IMPORTANT)
What is useEffect?
Runs side effects after render:
API calls
Subscriptions
Timers
DOM updates

Syntax
useEffect(() => {
  // side effect
  return () => {
    // cleanup
  };
}, [dependencies]);

Dependency Array Cases
1ï¸âƒ£ No dependency array
useEffect(() => {
  console.log("Runs on every render");
});

2ï¸âƒ£ Empty array []
useEffect(() => {
  console.log("Runs once (on mount)");
}, []);

3ï¸âƒ£ With dependencies
useEffect(() => {
  console.log("Runs when count changes");
}, [count]);

â— Async Inside useEffect (Correct Pattern)

âŒ Wrong

useEffect(async () => {
  const data = await fetchData();
}, []);


âœ” Correct
useEffect(() => {
  const loadData = async () => {
    const data = await fetchData();
  };
  loadData();
}, []);

ğŸ“Œ Reason: useEffect callback must return cleanup or nothing, not a Promise.

ğŸ”´ Cleanup Function (Interview Favorite)
Example â€“ Event Listener
useEffect(() => {
  window.addEventListener("resize", handleResize);

  return () => {
    window.removeEventListener("resize", handleResize);
  };
}, []);

ğŸ”µ Handling Async Events
Button Click with Async Task
const handleClick = async () => {
  const res = await fetch("/api/data");
  const data = await res.json();
  console.log(data);
};

<button onClick={handleClick}>Load</button>

ğŸ“Œ Events can safely be async
ğŸŸ¡ Promises (Core JavaScript Concept)
What is a Promise?
Represents future completion or failure of an async operation.
States:
Pending
Fulfilled
Rejected

Promise Example
fetchData()
  .then(data => console.log(data))
  .catch(err => console.error(err));

async/await (Preferred)
try {
  const data = await fetchData();
} catch (err) {
  console.error(err);
}

ğŸ“Œ Cleaner & readable
ğŸ”µ setTimeout & Timers
Delayed Execution
setTimeout(() => {
  console.log("Runs after 2 seconds");
}, 2000);

In React with Cleanup
useEffect(() => {
  const timer = setTimeout(() => {
    console.log("Executed");
  }, 1000);

  return () => clearTimeout(timer);
}, []);

ğŸ“Œ Prevents memory leaks

ğŸ”´ Avoiding Memory Leaks (IMPORTANT)
Problem
Component unmounts before async completes â†’ state update error

Solution
useEffect(() => {
  let isMounted = true;

  fetchData().then(data => {
    if (isMounted) setState(data);
  });

  return () => {
    isMounted = false;
  };
}, []);

ğŸ”µ Async + Redux (High Level)
dispatch(fetchUsers());

Handled via:
Redux Thunk
RTK Query

ğŸ“Œ Async logic outside component

ğŸ§  Interview Hack â€“ Strong Answer
Q: How do you handle async tasks in React?
I handle async tasks like API calls inside useEffect or event handlers using async/await. I manage loading and error states, clean up effects to avoid memory leaks, and ensure proper dependency handling.

ğŸ”¥ Common Interview Questions
Q: Why canâ€™t useEffect be async?
âœ” Because it must return cleanup, not a Promise

Q: Where should API calls be made?
âœ” Inside useEffect or async event handlers

Q: How do you cancel async calls?
âœ” Cleanup functions / abort controllers

âœ… One-Line Summary
Async tasks in React are handled using useEffect, async/await, promises, and proper cleanup to manage side effects without blocking the UI.

13) Reusability, Readability, modularity, testability (Coding Practices):
ğŸ”¹ Why Interviewers Ask This?
They want to know:
Can you write scalable code?
Can others understand & maintain your code?
Can it be tested and extended easily?

ğŸŸ¢ 1. Reusability
ğŸ”¹ What is Reusability?
Writing components/functions that can be used in multiple places without duplication.

âœ… Good Practices
Small components
Configurable via props
Avoid hardcoded values
Custom hooks for shared logic

âŒ Bad Example
function UserCard() {
  return <button style={{ color: "blue" }}>Submit</button>;
}

âœ… Good Example
function Button({ label, onClick, color = "blue" }) {
  return (
    <button style={{ color }} onClick={onClick}>
      {label}
    </button>
  );
}


ğŸ“Œ Interview line:
I design reusable components using props and avoid duplicating UI logic.

ğŸ”µ 2. Readability
ğŸ”¹ What is Readability?
Code should be easy to read and understand by other developers.

âœ… Readability Best Practices
Meaningful variable & function names
Small functions
Consistent formatting
Avoid deeply nested logic

âŒ Hard to Read
if(a && b && c && d){
  doSomething();
}

âœ… Easy to Read
const isFormValid = a && b && c && d;

if (isFormValid) {
  doSomething();
}


ğŸ“Œ Interview tip:
Readability reduces bugs and speeds up onboarding.

ğŸŸ£ 3. Modularity
ğŸ”¹ What is Modularity?
Breaking code into independent, self-contained modules.

Example Folder Structure
components/
  Button/
    Button.jsx
    Button.test.js
    Button.css
hooks/
  useFetch.js
services/
  api.js

Modular Component Example
// services/api.js
export const fetchUsers = () => fetch("/api/users");

// hooks/useUsers.js
export const useUsers = () => {
  // reusable logic
};

ğŸ“Œ Interview line:
I follow modular architecture to isolate concerns and improve maintainability.

ğŸ”´ 4. Testability
ğŸ”¹ What is Testability?
Code that is easy to test using unit and integration tests.

âœ… Testable Code Principles
Pure functions
Minimal side effects
Dependency injection
Avoid logic inside JSX

âŒ Hard to Test
<button onClick={() => setCount(count + Math.random())}>

âœ… Testable
const increment = (count) => count + 1;

<button onClick={() => setCount(increment(count))}>

Jest Unit Test
test("increment works", () => {
  expect(increment(1)).toBe(2);
});

ğŸ“Œ Interview line:
I keep business logic outside components to improve testability.

ğŸ”µ Reusability + Modularity = Custom Hooks
function useFetch(url) {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch(url).then(res => res.json()).then(setData);
  }, [url]);

  return data;
}

ğŸ“Œ Used across components â†’ clean + reusable

ğŸ§  Interview Hack â€“ Golden Answer
Q: How do you ensure clean code in React?
I focus on writing small reusable components, separating concerns using hooks and services, keeping code readable with clear naming, and ensuring everything is modular and testable.

ğŸ”¥ Common Interview Questions
Q: How do you avoid duplicate code?
âœ” Reusable components, hooks, utilities

Q: How do you improve testability?
âœ” Pure functions, isolated logic

Q: Why modularity matters?
âœ” Easier scaling, maintenance, testing

âœ… One-Line Summary
Clean coding practices focus on reusability, readability, modularity, and testability to build scalable and maintainable React applications.

14) Performance:
Performance optimization focuses on:
Faster load time
Smooth UI
Efficient rendering
Reduced bundle size

ğŸ”µ 1. Lazy Loading (Code Splitting)
What?
Load only what is needed, when itâ€™s needed.

Component Lazy Loading
import { lazy, Suspense } from "react";

const Dashboard = lazy(() => import("./Dashboard"));

function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <Dashboard />
    </Suspense>
  );
}


ğŸ“Œ Interview point:
Reduces initial bundle size
Improves first paint
Route-Based Lazy Loading

const Profile = lazy(() => import("./Profile"));

ğŸŸ¡ 2. Asset Optimization
What?
Reducing size of static assets.

Techniques
âœ” Minify JS & CSS
âœ” Gzip / Brotli compression
âœ” Remove unused CSS
âœ” Optimize images (WebP, SVG)

ğŸ“Œ Interview line:
I ensure assets are minified and compressed during build to reduce payload size.

ğŸ”µ 3. Writing Optimized Code (Best Practices)
Avoid Unnecessary Re-renders
React.memo(Component);

Memoize Expensive Calculations
const result = useMemo(() => heavyCalculation(data), [data]);

Memoize Functions
const handleClick = useCallback(() => {
  setCount(c => c + 1);
}, []);

ğŸ“Œ Prevents child re-rendering

ğŸ”´ 4. Bundlers (Webpack / Vite)
What is a Bundler?
Combines, minifies, and optimizes app files.
What Bundlers Do
Tree shaking (remove unused code)
Code splitting
Minification
Asset hashing

ğŸ“Œ Interview point:
Webpack optimizes bundles using tree-shaking and code-splitting for performance.

ğŸŸ£ 5. CDN / Server-Level Optimization
CDN (Content Delivery Network)
Serves static assets from nearest server
Reduces latency
Benefits

âœ” Faster load time
âœ” Reduced server load
âœ” Better global performance

ğŸ“Œ Interview line:
We serve static assets via CDN for faster global delivery.

ğŸ”µ 6. Rendering Optimization (VERY IMPORTANT)
Problem: Unnecessary Re-renders
Solutions
âœ” React.memo
const Button = React.memo(({ onClick }) => {
  return <button onClick={onClick}>Click</button>;
});

âœ” Key Usage in Lists
items.map(item => <Item key={item.id} />)

âœ” Avoid Inline Functions in JSX
// âŒ Bad
<button onClick={() => doSomething()} />

// âœ… Good
<button onClick={handleClick} />

ğŸ”´ Virtualization (Large Lists)
Example
Use libraries like react-window

ğŸ“Œ Renders only visible items

ğŸ§  Interview Hack â€“ Strong Answer
Q: How do you improve performance in React?
I improve performance by lazy loading components, optimizing assets, avoiding unnecessary re-renders using memoization, leveraging bundlers for code splitting, and serving static assets through CDNs.

ğŸ”¥ Common Interview Questions
Q: When to use useMemo?
âœ” Expensive calculations

Q: When to use useCallback?
âœ” Passing functions to memoized child components

Q: Does React.memo always help?
âŒ No, only when re-renders are costly

âœ… One-Line Summary
React performance optimization involves lazy loading, efficient bundling, asset optimization, CDN usage, and minimizing unnecessary component re-renders.

ğŸ”´ Virtualization (Large Lists)
Example
Use libraries like react-window

ğŸ“Œ Renders only visible items
Here are clear, interview-ready notes on Virtualization (Large Lists) with react-window, including why, how, and examples ğŸ‘‡
This is a favorite performance question in React interviews.

ğŸ”´ Virtualization (Large Lists)
ğŸ”¹ What is Virtualization?
Virtualization is a performance optimization technique where:
Only visible items in a list are rendered
Off-screen items are not mounted in the DOM

ğŸ‘‰ Prevents UI slowdown when rendering large datasets

ğŸ”¹ Why is Virtualization Needed?
Problem (Without Virtualization)
{items.map(item => <Row key={item.id} />)}

âŒ If items.length = 10,000

DOM becomes heavy
Slow rendering
High memory usage
Solution

Render only what the user sees + a small buffer.

ğŸ”µ react-window (Most Common Library)
ğŸ”¹ What is react-window?
A lightweight library by Brian Vaughn (React team) that:
Efficiently renders large lists
Supports fixed & variable item sizes
Very small bundle size

ğŸ”¹ Installation
npm install react-window

ğŸŸ¢ Fixed Size List Example
import { FixedSizeList as List } from "react-window";

const Row = ({ index, style }) => (
  <div style={style}>
    Row {index}
  </div>
);

function VirtualizedList() {
  return (
    <List
      height={400}
      itemCount={10000}
      itemSize={35}
      width="100%"
    >
      {Row}
    </List>
  );
}

ğŸ”¹ Explanation (Interview-Friendly)
height â†’ visible container height
itemCount â†’ total number of items
itemSize â†’ fixed height of each row
style â†’ must be applied for positioning

ğŸ“Œ Only ~10â€“15 rows render at a time instead of 10,000

ğŸŸ£ Variable Size List Example
import { VariableSizeList as List } from "react-window";

const getItemSize = index => index % 2 === 0 ? 50 : 80;

<List
  height={400}
  itemCount={1000}
  itemSize={getItemSize}
  width="100%"
>
  {Row}
</List>

ğŸ”µ Grid Virtualization
import { FixedSizeGrid as Grid } from "react-window";

<Grid
  columnCount={5}
  columnWidth={100}
  height={300}
  rowCount={1000}
  rowHeight={35}
  width={500}
>
  {({ columnIndex, rowIndex, style }) => (
    <div style={style}>
      {rowIndex}, {columnIndex}
    </div>
  )}
</Grid>

ğŸ“Œ Used for tables, dashboards

ğŸ”´ Key Rules (Very Important)
âœ” Always apply style prop
âœ” Use stable keys when possible
âœ” Avoid heavy components inside rows
âœ” Combine with React.memo

ğŸ§  Interview Hack â€“ Best Answer
Q: How do you handle large lists in React?
For large datasets, I use list virtualization libraries like react-window which render only visible items, significantly improving performance and reducing DOM load.

ğŸ”¥ react-window vs react-virtualized
react-window	react-virtualized
Lightweight	Heavy
Simple API	Feature-rich
Recommended	Legacy

âš ï¸ When NOT to Use Virtualization
âŒ Small lists
âŒ SEO-critical content
âŒ When full DOM access is required

âœ… One-Line Summary
Virtualization improves performance by rendering only visible list items, and libraries like react-window efficiently handle large datasets in React.

15) Styling:
ğŸ”¹ Why Styling Choices Matter?
Interviewers want to know:
Can you build scalable UI systems?
Do you understand trade-offs?
Can you work with design systems?

ğŸŸ¢ 1. CSS / SCSS (Traditional Styling)
ğŸ”¹ What?
Plain CSS or SCSS files imported into components

Example (SCSS)
.button {
  background-color: blue;
  color: white;

  &:hover {
    background-color: darkblue;
  }
}

import "./Button.scss";

<button className="button">Click</button>

âœ… Pros
âœ” Simple
âœ” No learning curve
âœ” Powerful with SCSS

âŒ Cons
âŒ Global scope issues
âŒ Class name conflicts

ğŸ“Œ Interview line:
I use SCSS for structured, maintainable styles in smaller to medium projects.

ğŸ”µ 2. Tailwind CSS (Utility-First)
ğŸ”¹ What?
A utility-first CSS framework using atomic classes.

Example
<button className="bg-blue-500 text-white px-4 py-2 rounded">
  Click
</button>

âœ… Pros
âœ” Fast development
âœ” No CSS files
âœ” Tree-shakable

âŒ Cons
âŒ Long class names
âŒ Hard to read initially

ğŸ“Œ Interview line:
Tailwind improves speed and consistency by eliminating custom CSS.

ğŸŸ£ 3. StyleX (Meta / Facebook)
ğŸ”¹ What?
A compile-time CSS-in-JS solution.

Example
import stylex from "@stylexjs/stylex";

const styles = stylex.create({
  button: {
    backgroundColor: "blue",
    color: "white",
  },
});

<button {...stylex.props(styles.button)}>Click</button>

âœ… Pros
âœ” Zero runtime cost
âœ” Scoped styles
âœ” Performant

âŒ Cons
âŒ New ecosystem
âŒ Limited community

ğŸ“Œ Interview line:
StyleX provides CSS-in-JS benefits without runtime overhead.

ğŸ”´ 4. Bootstrap
ğŸ”¹ What?
Pre-built CSS framework with components.

Example
<button className="btn btn-primary">Click</button>

âœ… Pros
âœ” Quick setup
âœ” Responsive grid
âœ” Widely known

âŒ Cons
âŒ Generic UI
âŒ Hard to customize deeply

ğŸ“Œ Interview line:
Bootstrap is useful for rapid prototyping.

ğŸŸ¡ 5. Material UI (MUI)
ğŸ”¹ What?
React component library based on Material Design.

Example
import Button from "@mui/material/Button";

<Button variant="contained">Click</Button>

âœ… Pros

âœ” Ready-made components
âœ” Theming support
âœ” Accessibility built-in

âŒ Cons
âŒ Large bundle size
âŒ Opinionated design

ğŸ“Œ Interview line:
MUI helps build accessible, enterprise-grade UIs quickly.

ğŸŸ  6. Ant Design (Ant UI)
ğŸ”¹ What?
Enterprise-focused React UI framework.

Example
import { Button } from "antd";

<Button type="primary">Click</Button>

âœ… Pros
âœ” Rich enterprise components
âœ” Tables, forms, modals
âœ” Strong design system

âŒ Cons
âŒ Heavy
âŒ Less flexible UI

ğŸ“Œ Interview line:
Ant Design is ideal for enterprise dashboards and admin panels.

ğŸ”µ Comparison Table (Interview Gold)
Styling	Best Use Case
CSS / SCSS	Custom design systems
Tailwind	Fast, modern apps
StyleX	Performance-critical apps
Bootstrap	Quick prototypes
MUI	Enterprise apps
Ant UI	Admin panels
ğŸ§  Interview Hack â€“ Best Answer

Q: Which styling approach do you prefer?
I choose styling based on project needs. For speed and consistency, I prefer Tailwind. For enterprise apps, MUI or Ant Design works well. For custom UI, SCSS or StyleX provides better control.

ğŸ”¥ Common Interview Questions

Q: CSS vs CSS-in-JS?
âœ” CSS is simple; CSS-in-JS provides scoping and theming

Q: How do you avoid CSS conflicts?
âœ” BEM, modules, scoped styles

Q: How do you handle theming?
âœ” CSS variables / MUI theme provider

âœ… One-Line Summary
React styling can be done using traditional CSS, utility-first frameworks, or component libraries, each chosen based on scalability, performance, and project needs.